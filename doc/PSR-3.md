# PSR-3: Интерфейс регистратора
Основная цель - позволить библиотекам получать

Psr\Log\LoggerInterface объект и записывать в него логи простым и универсальным способом. Фреймворки и CMS, у которых есть особые потребности, МОГУТ расширять интерфейс для своих собственных целей, но ДОЛЖНЫ оставаться совместимыми с этим документом. Это гарантирует, что сторонние библиотеки, которые использует приложение, могут записывать в централизованные журналы приложений.

Ключевые слова «ДОЛЖЕН», «НЕ ДОЛЖЕН», «ТРЕБУЕТСЯ», «ДОЛЖЕН», «НЕ ДОЛЖЕН», «ДОЛЖЕН», «НЕ ДОЛЖЕН», «РЕКОМЕНДУЕТСЯ», «МОЖЕТ» и «ДОПОЛНИТЕЛЬНО» в этом документе являются следует интерпретировать, как описано в RFC 2119 .

Слово implementorв этом документе следует интерпретировать как кто-то, реализующий LoggerInterfaceв связанной с журналом библиотеке или фреймворке. Пользователи логгеров называются user.

## 1. Спецификация
### 1.1 Основы
- Предоставляет LoggerInterfaceвосемь методов для записи журналов на восемь уровней RFC 5424 (отладка, информация, уведомление, предупреждение, ошибка, критическое, предупреждение, аварийное).

- Девятый метод logпринимает уровень журнала в качестве первого аргумента. Вызов этого метода с одной из констант уровня журнала ДОЛЖЕН иметь тот же результат, что и вызов метода, зависящего от уровня. Вызов этого метода с уровнем, не определенным в этой спецификации, ДОЛЖЕН вызывать, Psr\Log\InvalidArgumentException если реализация не знает об уровне. Пользователи НЕ ДОЛЖНЫ использовать настраиваемый уровень, не зная наверняка, что текущая реализация поддерживает его.

### 1.2 Сообщение
- Каждый метод принимает строку как сообщение или объект с __toString()методом. Разработчики МОГУТ иметь особую обработку переданных объектов. Если это не так, разработчики ДОЛЖНЫ преобразовать его в строку.

- Сообщение МОЖЕТ содержать заполнители, которые разработчики МОГУТ заменить значениями из массива контекста.

Имена заполнителей ДОЛЖНЫ соответствовать ключам в массиве контекста.

Имена заполнителей ДОЛЖНЫ быть разделены одной открывающей скобкой {и одной закрывающей скобкой }. НЕ ДОЛЖНЫ быть пробелы между разделителями и именем заполнителя.

Экземплификант должен состоять только из символов A-Z, a-z, 0-9, подчеркивание _, и периода .. Использование других символов зарезервировано для будущих модификаций спецификации заполнителей.

Разработчики МОГУТ использовать заполнители для реализации различных стратегий экранирования и перевода журналов для отображения. Пользователям НЕ СЛЕДУЕТ заранее экранировать значения заполнителей, поскольку они не могут знать, в каком контексте будут отображаться данные.

Ниже приведен пример реализации интерполяции заполнителя, предоставленный только для справки:
```php
> <?php
>
> /**
> * Interpolates context values into the message placeholders.
> */
> function interpolate($message, array $context = array())
> {
>    // build a replacement array with braces around the context keys
>    $replace = array();
>    foreach ($context as $key => $val) {
>        // check that the value can be cast to string
>        if (!is_array($val) && (!is_object($val) || method_exists($val, '__toString'))) {
>            $replace['{' . $key . '}'] = $val;
>        }
>    }
>
>    // interpolate replacement values into the message and return
>    return strtr($message, $replace);
> }
>
> // a message with brace-delimited placeholder names
> $message = "User {username} created";
>
> // a context array of placeholder names => replacement values
> $context = array('username' => 'bolivar');
>
> // echoes "User bolivar created"
> echo interpolate($message, $context);
```
