PSR-14: Диспетчер событий
Диспетчеризация событий - это распространенный и хорошо протестированный механизм, позволяющий разработчикам легко и последовательно внедрять логику в приложение.

Целью данного PSR является создание общего механизма для расширения и сотрудничества на основе событий, чтобы библиотеки и компоненты могли более свободно повторно использоваться между различными приложениями и фреймворками.

Ключевые слова «ДОЛЖЕН», «НЕ ДОЛЖЕН», «ТРЕБУЕТСЯ», «ДОЛЖЕН», «НЕ ДОЛЖЕН», «ДОЛЖЕН», «НЕ ДОЛЖЕН», «РЕКОМЕНДУЕТСЯ», «МОЖЕТ» и «ДОПОЛНИТЕЛЬНО» в этом документе являются следует интерпретировать, как описано в RFC 2119 .

Цель
Наличие общих интерфейсов для отправки и обработки событий позволяет разработчикам создавать библиотеки, которые могут взаимодействовать со многими фреймворками и другими библиотеками обычным образом.

Некоторые примеры:

Фреймворк безопасности, который предотвратит сохранение / доступ к данным, когда у пользователя нет разрешения.
Обычная система кэширования полной страницы.
Библиотеки, расширяющие другие библиотеки, независимо от того, в какой фреймворк они обе интегрированы.
Пакет журналов для отслеживания всех действий, предпринятых в приложении.
Определения
Событие - Событие - это сообщение, созданное Эмитентом . Это может быть любой произвольный объект PHP.
Слушатель - Слушатель - это любой вызываемый PHP, который ожидает передачи события. Ноль или более слушателей могут быть переданы одному и тому же событию. Слушатель МОЖЕТ поставить в очередь какое-то другое асинхронное поведение, если он того пожелает.
Эмиттер - Эмиттер - это любой произвольный код, который хочет отправить событие. Это также известно как «телефонный код». Он не представлен какой-либо конкретной структурой данных, но относится к варианту использования.
Диспетчер - Диспетчер - это служебный объект, которому эмиттер дает объект события. Диспетчер отвечает за передачу события всем соответствующим слушателям, но ДОЛЖЕН отложить определение ответственных слушателей Поставщику слушателей.
Провайдер слушателя - провайдер слушателя отвечает за определение того, какие слушатели подходят для данного события, но НЕ ДОЛЖЕН вызывать самих слушателей. Провайдер слушателя может указать ноль или более подходящих слушателей.
События
События - это объекты, которые действуют как единица связи между эмиттером и соответствующими слушателями.

Объекты событий МОГУТ быть изменяемыми, если вариант использования вызывает Слушатели, возвращающие информацию источнику. Однако, если такая двунаправленная связь не требуется, РЕКОМЕНДУЕТСЯ, чтобы событие было определено как неизменное; т.е. определен таким образом, что в нем отсутствуют методы мутатора.

Разработчики ДОЛЖНЫ предполагать, что один и тот же объект будет передан всем слушателям.

РЕКОМЕНДУЕТСЯ, но НЕ ОБЯЗАТЕЛЬНО, чтобы объекты Event поддерживали сериализацию и десериализацию без потерь; $event == unserialize(serialize($event))ДОЛЖЕН быть верным. Объекты могут использовать РНР Serializableинтерфейс, __sleep()или __wakeup()магические методы, или аналогичные функциональные возможности языка , если это необходимо.

Останавливаемые события
Преодолимая событие является частным случаем события , которое содержит дополнительные возможности для предотвращения дальнейших Слушателей от вызова. На это указывает реализация StoppableEventInterface.

Событие, реализующие StoppableEventInterfaceдолжен возвращать trueиз isPropagationStopped()когда все , что событие это представляет было завершено. Реализатор класса должен определить, когда это произойдет. Например, событие, которое запрашивает RequestInterfaceсопоставление объекта PSR-7 с соответствующим ResponseInterfaceобъектом, может иметь setResponse(ResponseInterface $res)метод для вызова Listener, который вызывает isPropagationStopped()возврат true.

Слушатели
Слушателем может быть любой вызываемый PHP. Слушатель ДОЛЖЕН иметь один и только один параметр - Событие, на которое он реагирует. Слушателям СЛЕДУЕТ напечатать намек на этот параметр настолько конкретно, насколько это актуально для их варианта использования; то есть, Слушатель МОЖЕТ указать тип интерфейса, чтобы указать, что он совместим с любым типом событий, реализующим этот интерфейс, или с конкретной реализацией этого интерфейса.

Прослушиватель ДОЛЖЕН иметь voidвозврат, и ДОЛЖЕН типовой намек, который возвращается явным образом. Диспетчер ДОЛЖЕН игнорировать значения, возвращаемые слушателями.

Слушатель МОЖЕТ делегировать действия другому коду. Это включает в себя прослушиватель, являющийся тонкой оболочкой вокруг объекта, который выполняет фактическую бизнес-логику.

Слушатель МОЖЕТ поставить в очередь информацию из События для последующей обработки вторичным процессом, используя cron, сервер очереди или аналогичные методы. Для этого он МОЖЕТ сериализовать сам объект Event; однако следует позаботиться о том, чтобы не все объекты Event можно было безопасно сериализовать. Вторичный процесс ДОЛЖЕН предполагать, что любые изменения, которые он вносит в объект Event, НЕ будут распространяться на другие слушатели.

Диспетчер
Диспетчер - это реализующий сервисный объект EventDispatcherInterface. Он отвечает за получение слушателей от поставщика слушателей для отправленного события и вызов каждого слушателя с этим событием.

Диспетчер:

ДОЛЖНЫ вызывать Listeners синхронно в том порядке, в котором они возвращаются от ListenerProvider.
ДОЛЖЕН возвращать тот же объект Event, который был передан после того, как он завершил вызов Listeners.
НЕ ДОЛЖНЫ возвращаться к эмиттеру до тех пор, пока все слушатели не будут выполнены.
Если передано останавливаемое событие, диспетчер

ДОЛЖЕН вызвать isPropagationStopped()событие до того, как будет вызван каждый слушатель. Если этот метод возвращает, trueон ДОЛЖЕН немедленно вернуть событие источнику и НЕ ДОЛЖЕН вызывать каких-либо дополнительных прослушивателей. Это означает, что если событие передается диспетчеру, который всегда возвращается trueиз isPropagationStopped(), то слушатели не будут вызываться.
Диспетчеру СЛЕДУЕТ предполагать, что любой прослушиватель, возвращаемый ему от поставщика прослушивателя, является типобезопасным. То есть диспетчеру СЛЕДУЕТ предполагать, что вызов $listener($event)не приведет к созданию файла TypeError.

Обработка ошибок
Исключение или ошибка, выдаваемые Слушателем, ДОЛЖНЫ блокировать выполнение любых последующих Слушателей. Исключение или ошибка, сгенерированные Слушателем, ДОЛЖНЫ быть разрешены для повторного распространения до Эмиттера.

Диспетчер МОЖЕТ поймать брошенный объект, чтобы зарегистрировать его, разрешить выполнение дополнительных действий и т. Д., Но затем ДОЛЖЕН повторно выбросить исходный бросаемый объект.

Провайдер слушателя
Поставщик прослушивателя - это объект службы, ответственный за определение того, какие прослушиватели имеют отношение к данному событию и должны вызываться для данного события. Он может определять как релевантные слушатели, так и порядок их возврата любыми средствами, которые он выбирает. Это МОЖЕТ включать:

Разрешение некоторой формы механизма регистрации, чтобы разработчики могли назначать слушателя событию в фиксированном порядке.
Получение списка применимых слушателей посредством отражения на основе типа и реализованных интерфейсов события.
Заблаговременное создание скомпилированного списка слушателей, к которым можно обращаться во время выполнения.
Реализация некоторой формы контроля доступа, чтобы определенные слушатели вызывались только в том случае, если текущий пользователь имеет определенное разрешение.
Извлечение некоторой информации из объекта, на который ссылается событие, такого как сущность, и вызов предопределенных методов жизненного цикла для этого объекта.
Делегирование ответственности одному или нескольким другим поставщикам прослушивателей с использованием произвольной логики.
Любая комбинация вышеперечисленного или других механизмов МОЖЕТ быть использована по желанию.

Поставщикам прослушивателей СЛЕДУЕТ использовать имя класса события, чтобы отличать одно событие от другого. Они МОГУТ также рассматривать любую другую информацию о мероприятии как соответствующую.

Провайдеры слушателей ДОЛЖНЫ относиться к родительским типам так же, как и к собственному типу события, при определении применимости слушателя. В следующем случае:

class A {}

class B extends A {}

$b = new B();

function listener(A $event): void {};
Провайдер слушателя ДОЛЖЕН рассматриваться listener()как применимый слушатель $b, поскольку он совместим по типу, если только некоторые другие критерии не препятствуют этому.

Состав объекта
Диспетчеру СЛЕДУЕТ составлять поставщика прослушивателя для определения соответствующих слушателей. РЕКОМЕНДУЕТСЯ, чтобы поставщик прослушивателя был реализован как отдельный объект от диспетчера, но это НЕ ТРЕБУЕТСЯ.

Интерфейсы
namespace Psr\EventDispatcher;

/**
 * Defines a dispatcher for events.
 */
interface EventDispatcherInterface
{
    /**
     * Provide all relevant listeners with an event to process.
     *
     * @param object $event
     *   The object to process.
     *
     * @return object
     *   The Event that was passed, now modified by listeners.
     */
    public function dispatch(object $event);
}
namespace Psr\EventDispatcher;

/**
 * Mapper from an event to the listeners that are applicable to that event.
 */
interface ListenerProviderInterface
{
    /**
     * @param object $event
     *   An event for which to return the relevant listeners.
     * @return iterable<callable>
     *   An iterable (array, iterator, or generator) of callables.  Each
     *   callable MUST be type-compatible with $event.
     */
    public function getListenersForEvent(object $event) : iterable;
}
namespace Psr\EventDispatcher;

/**
 * An Event whose processing may be interrupted when the event has been handled.
 *
 * A Dispatcher implementation MUST check to determine if an Event
 * is marked as stopped after each listener is called.  If it is then it should
 * return immediately without calling any further Listeners.
 */
interface StoppableEventInterface
{
    /**
     * Is propagation stopped?
     *
     * This will typically only be used by the Dispatcher to determine if the
     * previous listener halted propagation.
     *
     * @return bool
     *   True if the Event is complete and no further listeners should be called.
     *   False to continue calling listeners.
     */
    public function isPropagationStopped() : bool;
}